/// An error type that indicates the furthest-successful parse, and provides a 
/// stack trace detailing how the parser got there.
/// 
/// None of the structured parsers defined in ``/swift-grammar`` throw this error 
/// directly. Instead, the ``Grammar/DefaultDiagnostics`` engine computes it
/// based on the diagnostic engineâ€™s internal state when encountering 
/// invalid input.
/// 
/// Custom ``ParsingRule`` implementations should not throw this error either.
@frozen public 
struct ParsingError<Index>:TraceableError, CustomStringConvertible 
{
    /// A diagnostic stack frame, corresponding to a structured ``ParsingRule`` invocation.
    /// 
    /// Only the ``Grammar/DefaultDiagnostics`` engine tracks call stack state.
    @frozen public 
    struct Frame 
    {
        /// Indicates the position in the ``ParsingInput.source`` where 
        /// the parser started attempting to apply ``rule``.
        public 
        let index:Index 
        /// The parsing rule associated with this stack frame. 
        /// 
        /// This property is an [`Any`]() metatype, and not a 
        /// ``ParsingRule`` metatype, because this stack frame may have been 
        /// generated by a compound (tuple) rule.
        public 
        let rule:Any.Type 
        /// The ``ParsingRule//Construction`` type associated with 
        /// ``rule``, if ``rule`` is a ``ParsingRule``. If ``rule`` is a compound 
        /// (tuple) rule, this property contains a tuple of the same arity, 
        /// containing the ``ParsingRule//Construction`` types of each of its 
        /// subrules.
        public 
        let construction:Any.Type 
        /// Creates a stack frame.
        /// -   parameters:
        ///     - index: An index into an associated input source.
        ///     - rule: A metatype indicating the parsing rule associated with this stack frame.
        ///     - construction: A metatype indicating the expected parsing result of this stack frame.
        @inlinable public 
        init(index:Index, rule:Any.Type, construction:Any.Type)
        {
            self.index          = index 
            self.rule           = rule 
            self.construction   = construction
        }
    }
    /// Returns the string [`"parsing error"`]().
    public static 
    var namespace:String 
    {
        "parsing error"
    }
    /// The underlying parsing error.
    public 
    let problem:Error
    /// The index of the first invalid terminal in the input, or the ``Collection/.endIndex``
    /// of the input. 
    /// 
    /// If the parser attempted to apply multiple rules via backtracking, this 
    /// index comes from the longest successful parse.
    public 
    let index:Index
    public 
    let trace:[Frame]
    
    @inlinable public 
    init(at index:Index, because problem:Error, trace:[Frame])
    {
        self.problem    = problem
        self.index      = index 
        self.trace      = trace
    }
    public 
    var context:[String] 
    {
        trace.map 
        {
            if $0.construction is Void.Type
            {
                return "while validating pattern '\($0.rule)'"
            }
            else 
            {
                return "while parsing value of type '\($0.construction)' by rule '\($0.rule)'"
            }
        }
    } 
    public 
    var next:Error? 
    {
        self.problem 
    }
    
    static 
    func annotate<Background>(_ range:Range<Index>, on background:Background, 
        line render:(Background.SubSequence) -> String, 
        newline predicate:(Background.Element) -> Bool) 
        -> String 
        where Background:BidirectionalCollection, Background.Index == Index
    {
        // `..<` means this will print the previous line if the problematic 
        // index references the newline itself
        let beginning:String, 
            middle:String
        if let start:Index  = background[..<range.lowerBound].lastIndex (where: predicate)
        {
            // can only remove newline if there is actually a preceeding newline 
            beginning = render(background[start..<range.lowerBound].dropFirst())
        }
        else 
        {
            beginning = render(background[..<range.lowerBound])
        } 
        let line:String
        let   end:Index     = background[range.lowerBound...].firstIndex(where: predicate) ?? 
            background.endIndex
        if range.upperBound < end 
        {
            middle  = render(background[range])
            line    = beginning + middle + render(background[range.upperBound..<end])
        }
        else 
        {
            middle  = render(background[range.lowerBound..<end])
            line    = beginning + middle 
        }
        return 
            """
            \(line)
            \(String.init(repeating: " ", count: beginning.count))^\(String.init(repeating: "~", count: middle.count).dropLast())
            """
    }
    public 
    func annotate<Background>(source background:Background, 
        line:(Background.SubSequence) -> String, newline:(Background.Element) -> Bool) 
        -> String 
        where Background:BidirectionalCollection, Background.Index == Index
    {
        """
        \(String.init(reflecting: type(of: self.problem))): \(self.problem)
        \(Self.annotate(background.index(before: self.index) ..< self.index, on: background, line: line, newline: newline))
        \(self.trace.map
        {
            (frame:Frame) in
            
            let heading:String 
            if frame.construction is Void.Type
            {
                heading = "note: expected pattern '\(String.init(reflecting: frame.rule))'"
            }
            else 
            {
                heading = "note: while parsing value of type '\(String.init(reflecting: frame.construction))' by rule '\(String.init(reflecting: frame.rule))'"
            }
            return "\(heading)\n\(Self.annotate(frame.index ..< self.index, on: background, line: line, newline: newline))"
        }.reversed().joined(separator: "\n"))
        """
    }
}
